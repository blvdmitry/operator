.root {
  position: relative;
}

.scroll {
  overflow: auto;
}

.table {
  border-collapse: separate;
  border-spacing: 0;
  width: 100%;
  border-radius: var(--bui_border_radius_200);
  border: var(--bui_border_width_100) solid var(--bui_color_border_alt);
  background: var(--bui_color_background_elevation_one);
}

/* Cell */
.head .row:last-child .cell,
.cell {
  border-block-end: var(--bui_border_width_100) solid
    var(--bui_color_border_alt);
}

.cell {
  padding: var(--bui_spacing_4x);
  vertical-align: top;

  /* Keep expected size when someone passes a cell size with `width` property */
  box-sizing: border-box;
}

.cell--head {
  @apply --bui_font_strong_2;
  text-align: start;
}

.cell--action {
  padding-inline-end: 0;
  padding-inline-start: var(--bui_spacing_4x);
  width: 0;
}

.cell--align-center {
  text-align: center;
}

.cell--align-end {
  text-align: end;
}

/* Row */
.row:last-child > .cell {
  border-block-end: 0;
}

.row--vertical-align-center .cell {
  vertical-align: middle;
}

.row--collapsible .cell {
  padding-block-start: 0;
  display: none;
}

/*
  Last child of the expandable rows is the expansion.
  Therefore, we select the previous row to hide the border in collapsed mode.
*/
.row--collapse-toggle:nth-last-child(2) .cell {
  border-block-end: 0;
}

.row--expanded .cell {
  border-block-end: 0;
}

.row--expanded + .row--collapsible .cell {
  display: table-cell;
}

.row--expanded .expand-button {
  transform: rotate(180deg);
  transform-origin: 50% 50%;
}

.row--selected {
  background: var(--bui_color_action_background_alt);
}

/* Modifiers */
.root--borderless .table {
  border: 0;
  background: transparent;
}

.root--borderless .cell:first-child {
  padding-inline-start: 0;
}

.root--borderless .cell:last-child {
  padding-inline-end: 0;
}

.root--compact .cell {
  padding: var(--bui_spacing_2x);
}

.root--compact .cell--action {
  padding-inline-end: 0;
  padding-inline-start: var(--bui_spacing_2x);
}

.root--sticky-header .head {
  position: sticky;
  inset-block-start: 0;
  background: var(--bui_color_background_elevation_two);
  z-index: var(--bui_z_index_4);
}

[dir="rtl"] .root--faded-start,
.root--faded-end {
  mask-image: linear-gradient(
    to right,
    rgba(0, 0, 0, 1) 0,
    rgba(0, 0, 0, 1) 80%,
    rgba(0, 0, 0, 0.1) 95%,
    rgba(0, 0, 0, 0) 100%
  );
  -webkit-mask-image: linear-gradient(
    to right,
    rgba(0, 0, 0, 1) 0,
    rgba(0, 0, 0, 1) 80%,
    rgba(0, 0, 0, 0.1) 95%,
    rgba(0, 0, 0, 0) 100%
  );
}

[dir="rtl"] .root--faded-end,
.root--faded-start {
  mask-image: linear-gradient(
    to left,
    rgba(0, 0, 0, 1) 0,
    rgba(0, 0, 0, 1) 80%,
    rgba(0, 0, 0, 0.1) 95%,
    rgba(0, 0, 0, 0) 100%
  );
  -webkit-mask-image: linear-gradient(
    to left,
    rgba(0, 0, 0, 1) 0,
    rgba(0, 0, 0, 1) 80%,
    rgba(0, 0, 0, 0.1) 95%,
    rgba(0, 0, 0, 0) 100%
  );
}

.root--faded-both {
  mask-image: linear-gradient(
    to right,
    rgba(0, 0, 0, 0) 0,
    rgba(0, 0, 0, 0.1) 5%,
    rgba(0, 0, 0, 1) 20%,
    rgba(0, 0, 0, 1) 80%,
    rgba(0, 0, 0, 0.1) 95%,
    rgba(0, 0, 0, 0) 100%
  );
  -webkit-mask-image: linear-gradient(
    to right,
    rgba(0, 0, 0, 0) 0,
    rgba(0, 0, 0, 0.1) 5%,
    rgba(0, 0, 0, 1) 20%,
    rgba(0, 0, 0, 1) 80%,
    rgba(0, 0, 0, 0.1) 95%,
    rgba(0, 0, 0, 0) 100%
  );
}

/* 
This is a simple way to enable position: sticky for desktop to avoid implementing it with JS while there are no requests for mobile sticky header
In the future this can be replaced with container queries to be based on the parent width instead of the whole screen
*/
@media (--bui_large_viewport) {
  .scroll {
    overflow: visible;
  }
}
